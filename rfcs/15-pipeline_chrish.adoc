= Shell-like DSL for _ChRIS_ Pipelines
Jennings <Jennings.Zhang@childrens.harvard.edu>
:status: INCOMPLETE DRAFT

Status: {status}

== tl;dr Example

The following is a file representation of a _ChRIS_ pipeline.

.dicom2minc.chri.sh
[source,shell]
----
#!/usr/bin/env chrs pipeline
## Description: Convert a directory containing DICOM series to MINC files.
## Category: MRI Processing

pl-dircopy --dir $1 ./subjects
pl-dcm2niix ./subjects ./nifti

## version: 1.1.0
pl-nii2mnc --unsigned --byte ./nifti ./minc
----

Observe that the syntax is a strict subset of `sh`.
There are various ways you can run this file:

[source,shell]
----
# Execute this pipeline directly on your host using Apptainer/Singularity/Docker/Podman
./dicom2minc.chri.sh /path/to/input/data
# or
./dicom2minc.chri.sh /path/to/input/data --using docker
./dicom2minc.chri.sh /path/to/input/data --using podman
./dicom2minc.chri.sh /path/to/input/data --using apptainer

# Execute this pipeline on ChRIS
./dicom2minc.chri.sh --on chris
# or
./dicom2minc.chri.sh --on chris --address https://cube.chrisproject.org/api/v1/

# Convert this .chri.sh pipeline to a bash script
chrs convert dicom2minc.chri.sh dicom2minc.sh
cat dicom2minc.sh
#!/bin/bash -ex
# Author: jennings.zhang <jz@babyMRI.org>
# Description: Convert a directory containing DICOM series to MINC files.
#
# This file was automatically generated by the command:
#     chrs convert dicom2minc.chri.sh dicom2minc.sh

if ! [ -d "$1" ] || ! [ -d "$2" ]; then
  echo "usage: $0 inputdir/ outputdir/"
  exit 1
fi

mkdir -vp $2/subjects $2/nifti $2/minc

# [chrs convert] >>> pl-dircopy --dir $1 ./subjects
cp -rv $1 $2/subjects

# [chrs convert] >>> pl-dcm2niix ./subjects ./nifti
apptainer exec -B $2/subjects:/incoming:ro -B $2/nifti:/outgoing:rw docker://fnndsc/pl-dcm2niix:0.1.0 /incoming /outgoing

# [chrs convert] >>> pl-nii2mnc --unsigned --byte ./nifti ./minc
apptainer exec -B $2/nifti:/incoming:ro -B $2/minc:/outgoing:rw docker://fnndsc/pl-nii2mnc:1.1.0 --unsigned --byte /incoming /outgoing
----

== Background

_ChRIS_ pipelines chain together _ChRIS_ plugins so that they can be rerun as workflows.

=== History of _ChRIS_ Pipelines...

\... To my knowledge, up until this point (2023-07-26)

1. In the beginning, the first canonical and "best-practice" way to create a _ChRIS_ pipeline was by creating it from a plugin instance. _CUBE_ would "snapshot" the plugin instance and its descendants as a pipeline. It was also possible to create a pipeline by POSTing a `plugin_tree` JSON string to `api/v1/pipelines/`.
2. _ts_-type plugins are introduced, however they cannot be used in pipelines.
3. xref:./2-pipeline_yaml.adoc[RFC #2] was introduced and implemented, eventually leading to the acceptance of the xref:../specs/YAML_Pipelines.adoc[_ChRIS_ YAML Pipelines] as canonical.
4. April to May 2023, _CUBE_ added direct support for YAML pipelines and even supporting _ts_-type plugins in pipelines.

=== Motivation

An important concept of _ChRIS_ plugins is that they are as easy to run outside _ChRIS_ as it is to run within _ChRIS_. That has never been true about _ChRIS_ pipelines.

There is also chatter about creating a user experience which is very familiar to people who are already comfortable with shell, see xref:./13-ChRISFS.adoc[RFC #13] and https://github.com/FNNDSC/cfs

xref:../specs/YAML_Pipelines.adoc[YAML Pipelines] are the status quo. However, the YAML pipeline specification was originally intended to be "syntactical sugar" for the `plugin_tree` JSON schema, so the YAML pipeline spec has confusing and wordy elements, especially to those unfamiliar with the original `plugin_tree` JSON schema.

The goal of this document is to propose a _ChRIS_ pipeline representation with two aims:

- a pipeline file representation should be **immediately familiar and legible to new users**.
- a pipeline file representation should be **as-easy to execute on the host** as it is to execute in _ChRIS_.

== Part 1: Description of a ChRIS Pipeline Shell-Like DSL "ChRI.sh"

TODO

=== ts-type plugin instances a.k.a. joins

Trivial and transparent.

[source,shell]
----
pl-nii2mnc --unsigned --byte input/ labels/
pl-nums2mask -m 'white_matter.mnc:161,5' labels/ all_masks/
pl-nums2mask -m 'gray_matter.mnc:163,161,5' labels/ all_masks/
pl-mri-preview --units-fallback mm all_masks/ images/
----

This example is translated as:

[cols="1,2,3"]
|===
|Plugin Instance ID|Plugin Name|Plugin Instance Parameters

| 1
| pl-nii2mnc
| `--unsigned --byte`

| 2
| pl-nums2mask
| `-m 'white_matter.mnc:161,5'`

| 3
| pl-nums2mask
| `-m 'gray_matter.mnc:163,161,5'`

| 4
| pl-topologicalcopy
| `--plugininstances 2,3`

| 5
| pl-mri-preview
| `--units-fallback mm`
|===

== Part 2: Development of Tooling to Support "ChRI.sh"

TODO